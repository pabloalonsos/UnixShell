/*
 * =====================================================================================
 *
 *       Filename:  shell.c
 *
 *    Description:  C-Shell Implementation
 *
 *        Version:  1.0
 *        Created:  10/01/2014
 *       Compiler:  gcc
 *
 *         Author:  Pablo Alonso
 *
 * =====================================================================================
 */

#define _GNU_SOURCE

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/wait.h>

#define MAXBUFFSIZE 2048
#define MAXCOMMSIZE 512

/*
 * Prints the PS1 environment variable as prompt or the default.
 */
void printPrompt(void);

/*
 * Allocates memory safely and throws an error if it fails
 */
void *secureMalloc(size_t sizeToAlloc, char *errMsg);

/*
 * It returns the size of an array that has NULL as tail
 */
int sizeOfArray(char **array);

/*
 * This method divides the input string of commands into an array of elements in which the following 
 * characters have their own char *:
 *  ">", ">>", ">&", "<"
 * The rest of the elements of the array are the commands to be run (e.g. ls -la, echo, etc)
 */
char **parseCommand(char *commandInput);

/*
 * It returns the position in the array of commands the position of an input redirection character
 * If it doesn't find any, it returns 0
 */
int inputPosition(char **args);

/*
 * It returns the position in the array of commands the position of an output redirection character
 * If it doesn't find any, it returns 0
 */
int outputPosition(char **args);

/*
 * It sets the output redirection of the forms ">", ">>" and ">&"
 */
void redirectOutput(char **args, int fdOut, int err, int outPos);

/*
 * It sets the output redirection of the forms "<"
 */
void redirectInput(char **args, int fdIn, int err, int inPos);

/*
 * It executes the method close() on the file descriptor passed
 */
void closeRedirect(int fd);

/*
 * It tokenizes the elements of the command. This is, if we have a command with options,
 * it will tokenize the command and then each of the options.
 */
char **getParams(char *params);

/*
 * It safely calls execvp passing the command and arguments
 */
void execute(char *args);

/*
 * It sets the necessary redirection and executes the commands parsed previously
 */
void evaluateCmd(char **cmd);

/*
 * It loops through the commands array when it's already separated into commands and pipes in the way {command, "|", command, "|", command, etc}
 * and increases a counter for everey !pipe that it finds. It returns that counter
 */
int getCommandNum(char **cmds);

/*
 * It returns the position in the array of commands of the first pipe or 0 if it doesn't find any
 */
int pipePosition(char **args);

/*
 * It tokenizes the input command into tokens and checks if it finds a pipe character. If so, it will create a string with the previous
 * tokens, append them to a new array, append the pipe character and reset the buffer for the next set of tokens that will compose a new
 * command.
 *      e.g. setpipes("hello I am pablo | the answer is 42") will return:
 *           {"hello I am pablo", "|", "the answer is 42"}
 */
char **setPipes(char *cmds);

/*
 * This method will process the command array generated by the method 'setPipes' and set up pipes for children processes.
 * It will create a pipe per every "|" in the cmds array, and it will fork processes per every command in cmds.
 * Then it loop through the commands and set up the pipes accordingly to the syntax of the initial input command.
 * Once the pipes are set the commands will be executed and the output of a command will be redirected to the input of the next one.
 */
void pipeline(char **cmds);

int main(int argc, char *argv[]){

    size_t bufferSize = MAXBUFFSIZE;
    char *cmdInput;

    char **sepCmds; //Will store each command separated by |

    while (1){
        // print prompt
        printPrompt();
        cmdInput = secureMalloc(bufferSize * sizeof(char), "Couldn't allocate memory for the input command");

        // get & parse command
        getline(&cmdInput, &bufferSize, stdin); // get input

        if(!strcmp(cmdInput, "exit\n") || !strcmp(cmdInput, "exit")){
            printf("Now exiting...\n");
            free(cmdInput);
            return 0;
        }

        sepCmds = setPipes(cmdInput);

        pipeline(sepCmds);

        for(int i = 0; i < MAXBUFFSIZE; i++){
            sepCmds[i] = NULL;
        }

        free(cmdInput);

    }

    return 0;
}

void printPrompt(void){
    char* PS1 = getenv("PS1");
    if (PS1) printf("%s ",PS1);
    else printf("â™ž :: ");
}

void *secureMalloc(size_t sizeToAlloc, char *errMsg){
    void *mem = malloc(sizeToAlloc);
    // memory allocation error check
    if(!mem){
        printf("%s\n", errMsg);
        perror("Failed to allocate memory.");
        exit(EXIT_FAILURE);
    }
    return mem;
}

int sizeOfArray(char **array){
    int size = 0;
    while(array[size]!=NULL) size++;
    return size;
}

char **parseCommand(char *commandInput){
    char *token;
    char *tmpStr = secureMalloc(MAXCOMMSIZE * sizeof(char), "Couldn't allocate mem for temporary parsing string.");
    char **parsedArray = secureMalloc(MAXBUFFSIZE * sizeof(char*), "Couldn't allocate memory for the command parsed array.");
    int argPos = 0;

    // Ignore leading spaces
    while(*commandInput && (*commandInput == ' '))
        commandInput++;

    token = strtok(commandInput, " \n");

    while(token != NULL){
        if(strcmp(token, "<")==0){
            parsedArray[argPos++] = tmpStr;
            parsedArray[argPos++] = "<";
            tmpStr = secureMalloc(MAXCOMMSIZE * sizeof(char), "Couldn't allocate mem for temporary parsing string.");
        } else if (strcmp(token, ">") == 0){
            parsedArray[argPos++] = tmpStr;
            parsedArray[argPos++] = ">";
            tmpStr = secureMalloc(MAXCOMMSIZE * sizeof(char), "Couldn't allocate mem for temporary parsing string.");
        } else if (strcmp(token, ">>") == 0){
            parsedArray[argPos++] = tmpStr;
            parsedArray[argPos++] = ">>";
            tmpStr = secureMalloc(MAXCOMMSIZE* sizeof(char), "Couldn't allocate mem for temporary parsing string.");
        } else if (strcmp(token, ">&") == 0){
            parsedArray[argPos++] = tmpStr;
            parsedArray[argPos++] = ">&";
            tmpStr = secureMalloc(MAXCOMMSIZE * sizeof(char), "Couldn't allocate mem for temporary parsing string.");
        } else {
            strcat(tmpStr," ");
            strcat(tmpStr,token);
        }
        token = strtok(NULL," ");
    }

    parsedArray[argPos++] = ++tmpStr;

    return parsedArray;
}

// Returns position of stdin redirect token '<' or 0 otherwise
int inputPosition(char **args){
    int pos = 0;
    while(*args != NULL){
        if(!strcmp(*args, "<")){
            // Check syntax: token must have arguments at both sides
            if((*(args+1) != NULL) && (*(args-1) != NULL))
                return pos;
        }
        pos++;
        args++;
    }
    return 0;
}

int outputPosition(char **args){
    int pos = 0;
    while(*args != NULL){
        if((!strcmp(*args,">")) || (!strcmp(*args,">>")) || (!strcmp(*args,">&"))){
            // Check syntax: token must have arguments at both sides
            if((*(args+1) != NULL) && (*(args-1) != NULL))
                return pos;
        }
        pos++;
        args++;
    }
    return 0;
}

//returns first | position
int pipePosition(char **args){
    int pos = 0;
    while(*args != NULL){
        if(!strcmp(*args, "|")){
            if ((*(args+1) != NULL) && (*(args-1) != NULL)){
                return pos;
            }
        }
        pos++;
        args++;
    }
    return 0;
}

char **getParams(char *params){
    char **commandTokens = secureMalloc(MAXCOMMSIZE * sizeof(char*), "Couldn't allocate mem for temporary parsing string.");
    char *token = strtok(params, " \n");
    int arrayPos = 0;

    // We tokenize the command and arguments, and we eliminate the line-break at the end of the command.
    while(token != NULL){
        // Add the token to the array string and then gets the next argument
        commandTokens[arrayPos++] = token;
        token = strtok(NULL, " ");
    }
    commandTokens[arrayPos] = NULL;
    return commandTokens;
}


void execute(char *args){
    char **argv = getParams(args);
    if(execvp(argv[0],argv) < 0){ //execute command
        perror("Command not found.\n");
        exit(1);
    } 
}

void redirectInput(char **args, int fdIn, int err, int inPos){
    fdIn = open (args[inPos+1], O_RDONLY);
    if(fdIn < 0){
        perror("file descriptor stdin error");
        exit(1);
    }

    if (dup2(fdIn, STDIN_FILENO) < 0) perror("error dup2ing stdin");

    args[inPos] = NULL;

}

void redirectOutput(char **args, int fdOut, int err, int outPos){
    if(!strcmp(args[outPos], ">&"))
        err = 1;

    if(!strcmp(args[outPos], ">>")){
        fdOut = open(args[outPos+1], O_WRONLY|O_CREAT|O_APPEND, 0644);
        if(fdOut < 0){
            perror("file descriptor stdout append error");
            exit(1);
        }
    } else {
        fdOut = open (args[outPos+1], O_WRONLY|O_CREAT|O_TRUNC, 0644);
        if(fdOut < 0){
            perror("file descriptor stdout replace error");
            exit(1);
        }
    }

    if (dup2(fdOut, STDOUT_FILENO) < 0) perror("error dup2ing stdout");
    if(err)
        if (dup2(fdOut, STDERR_FILENO) < 0) perror("error dup2ing stderr");

    args[outPos] = NULL;
}

void closeRedirect(int fd){
    if (close(fd) < 0) perror("Error closing file descriptor");
}

void evaluateCmd(char **args){

    int inPos, outPos, err = 0;
    int fdIn = 0,
        fdOut = 0;

        if(sizeOfArray(args)>1){
            inPos = inputPosition(args);
            outPos = outputPosition(args);

            // I/O redirection
            if(inPos && outPos){
                // stdout must go before stdin
                if(inPos > outPos){
                    printf("Please use simple I/O redirection\n");
                } else {
                    redirectInput(args, fdIn, err, inPos);
                    redirectOutput(args, fdOut, err, outPos);

                    execute(args[0]);

                    closeRedirect(fdIn);
                    closeRedirect(fdOut);
                }
            } else if(inPos > 0){  // Input Redirection
                redirectInput(args, fdIn, err, inPos);

                execute(args[0]);

                closeRedirect(fdIn);
            } else if(outPos > 0){ // Output Redirection
                redirectOutput(args, fdOut, err, outPos);

                execute(args[0]);

                closeRedirect(fdOut);
            }
        } else {
            execute(args[0]);
        }
}

char **setPipes(char *cmds){

    char *token;
    char *tmpStr = secureMalloc(MAXCOMMSIZE * sizeof(char), "Couldn't allocate mem for temporary parsing string.");
    char **parsedArray = secureMalloc(MAXBUFFSIZE * sizeof(char*), "Couldn't allocate memory for the parsed array.");
    int argPos = 0;

    // replace trailing \n with empty char
    cmds[strlen(cmds)-1] = '\0';

    // Ignore leading spaces
    while(*cmds && (*cmds == ' '))
        cmds++;

    token = strtok(cmds, " \n");

    while(token != NULL){
        if(strcmp(token, "|")==0){
            parsedArray[argPos++] = tmpStr;
            parsedArray[argPos++] = "|";
            tmpStr = secureMalloc(MAXCOMMSIZE * sizeof(char*), "Couldn't allocate mem for temporary parsing string.");
        } else {
            strcat(tmpStr," ");
            strcat(tmpStr,token);
        }
        token = strtok(NULL," ");
    }

    parsedArray[argPos++] = ++tmpStr;
    parsedArray[argPos] = NULL;

    return parsedArray;
}

int getCommandNum(char **cmds){
    int count = 0;

    for(size_t i=0; i<sizeOfArray(cmds); i++){
        if(strcmp(cmds[i],"|") != 0){
            count++;
        }
    }
    return count;
}

void pipeline(char **cmds){

    int commandNum = getCommandNum(cmds),
        pid, status, mpid,
        sizeCmds = sizeOfArray(cmds),
        pipeNum = sizeCmds - commandNum,
        pipePos = pipePosition(cmds),
        pipefds[pipeNum*2];

    if(pipePos){
        if((mpid=fork()) == 0){

            for(int i=0; i<pipeNum; i++){ // create pipes
                if(pipe(pipefds + i*2) < 0){
                    perror("error creating pipes");
                }
            }

            int pipeTrack = 0;
            for(int i=0; i<commandNum; i++){

                pipePos = pipePosition(cmds);

                if((pid = fork()) == 0){

                    if(i != (commandNum - 1)){ // If it's not last command
                        if(dup2(pipefds[pipeTrack+1], STDOUT_FILENO) < 0)
                            perror("error dup2ing to STDOUT");
                    }

                    if(pipeTrack != 0){  // If it's not first command
                        if(dup2(pipefds[pipeTrack-2], STDIN_FILENO) < 0)
                            perror("error dup2ing to STDIN");
                    }

                    for (int i=0; i<2*pipeNum; i++){
                        close(pipefds[i]);
                    }

                    if(!pipePos){
                        evaluateCmd(parseCommand(cmds[sizeCmds-1]));
                    } else{
                        evaluateCmd(parseCommand(cmds[pipePos-1]));
                    }

                    perror("Error evaluating commands");
                    exit(1);

                }
                cmds[pipePos] = NULL;
                pipeTrack += 2;
            }

            for(int i = 0; i < 2 * pipeNum; i++){
                close(pipefds[i]);
            }
            for(int i = 0; i < pipeNum + 1; i++)
                wait(&status);


        } else {
            waitpid(mpid, &status, 0);
            exit(0);
        }

    } else {
        if((pid=fork()) == 0){
            evaluateCmd(parseCommand(cmds[0])); // evaluate command
        } else {
            wait(&status);  
        }
    }
}
